OTHER
this_site,_typeset_by_perl

<p>
This site is generated by an ugly perl script. I used to use a very
elegant short bash script, but then I got a bit interested in
non-hierarchical dynamically generated organizational schemes.
And that's a gateway...
</p>

<p>
The script reads a directory of posts, reads tags, generates menus as
needed (and as many colors I have), makes a template, and uses
that with s/// to write the pages. 
</p>

<p>
Much like the critters that populate this earth, it's ugly, 
it's custom, it's flawed, it's a mismash of baling wire and
hashes and slurps, it's not sustainable or maintainable except
by the natural selection of unit death, one day it will fade away
but for the moment - it just works.
</p>

<!--- reminder: sub out <> using:
s/</&lt;/g
s/>/&gt;/g
--->

<pre>
<code>
#!/usr/bin/perl -w
use strict;

  # Here, we slurp in the raw base index file. So this has MENUZ
  # defined where the menus go.

$/ = undef;
open(INDEX,"&lt;","rawindex.html") or die;
my $baseindex = &lt;INDEX&gt;;
close INDEX;
$/ = "\n";

  # I expect all the posting files, from which the menus are 
  # generated, to be in posts folder, with a .z so I can tell which
  # ones to include

my @postFiles=split(/\n/,`/usr/bin/ls posts/*.z`);

  # For each of those post files, then grab it, parse the tags from
  # the header, store the HTML of it. Posts should be written in
  # HTML, with the first line having a capital letter tag and the
  # second line having an underscore seperated title (underscore
  # so it plays nicely in bash, I've forgotten why...)

my %postsByTag;
for my $postFile (@postFiles) {
  open(THISPOST,"&lt;",$postFile) or die;
  my @file = &lt;THISPOST&gt;;
  for my $tag (split(/\s/,$file[0])) {
    chomp $file[1];
    push(@{$postsByTag{$tag}}, [$postFile, $file[1], [splice(@file,2)] ] );
  }
}

  # These are the colors for dynamic mouse over coloring

my @colors = ("#fc8d62","#8da0cb","#ffff99","#e78ac3");
my @menus;

  # modify the foreach loop to specify which menus to actually
  # publish, that is to say which tags are published

print "typesetting with menus: ";
for my $tag ( grep(/(SCIENCE)|(OTHER)|(LINKLIST)/, 
                sort(keys(%postsByTag)))) {
  die "need more colors" if @colors == 0;
  print $tag." ";
    # dynamically generate css. why not.
  my $tmp = "
    &lt;style&gt; 
      #menu".$tag.":hover {background:".shift(@colors)."} 
    &lt;/style&gt;
    &lt;li id=\"menu".$tag."\"&gt;
    &lt;p&gt;".$tag."&lt;/p&gt;
    &lt;ul&gt;";
  for my $i (@{$postsByTag{$tag}}) {
    ${$i}[0] =~ s/posts\/(.*).z$/$1/;
    ${$i}[1] =~ tr/_/ /;
    $tmp .= "&lt;a href=\"./".${$i}[0].".html\"&gt;&lt;li&gt;".
      ${$i}[1]."&lt;/li&gt;&lt;/a&gt;\n";
  }
  $tmp .= "
    &lt;/ul&gt;
    &lt;/li&gt;";
  push(@menus,$tmp);
}
print "\n";

  # and then we just put all that HTML into it's position

$baseindex =~ s/MENUZ/@menus/;

  # and then generate the actual pages for each post

print "printing pages: ";
for my $tag (grep(/(SCIENCE)|(OTHER)|(LINKLIST)/,keys(%postsByTag))) {
  print $tag." ";
  for my $i (@{$postsByTag{$tag}}) {
    open(OUT,"&gt;",${$i}[0].".html");
    my $thisPage = $baseindex;
    $thisPage =~ s/MAIN/@{${$i}[2]}/;
    print OUT $thisPage;
    close OUT;
  }
}

  # then we actually spit out the finished index.html file and exit

open(OUT,"&gt;","index.html");
$baseindex =~ s/MAIN//;
print OUT $baseindex;
close OUT;
print "index";
print "\n";
</code>
</pre>


